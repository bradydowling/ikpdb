# coding: utf-8

import unittest
import os
import subprocess
import time
import socket
import logging
import json


_logger = logging.getLogger(__file__)
_logger.addHandler(logging.StreamHandler())
_logger.setLevel(logging.INFO)



class IKPdbConnectionError(Exception):
    pass


class IKPdbClient(object):
    
    MAGIC_CODE = "LLADpcdtbdpac"
    MESSAGE_TEMPLATE = "length=%%s%s%%s" % MAGIC_CODE
    SOCKET_BUFFER_SIZE = 4096  # Maximum size of a packet received from client
    
    def __init__(self, host, port=15470):
        """ Create a client and connect to IKPdbClient
        """
        self._host = host
        self._port = port
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._socket.connect((self._host, self._port))
        self._received_data = ''
        self._msg_id = 100
    
    def encode(self, obj):
        json_obj = json.dumps(obj)
        return self.MESSAGE_TEMPLATE % (len(json_obj), json_obj,)
    
    def decode(self, message):
        json_obj = message.split(self.MAGIC_CODE)[1]
        obj = json.loads(json_obj)
        return obj

    def log_received(self, msg):
        _logger.debug("Received %s bytes >>>%s<<<", len(msg), msg)

    def log_sent(self, msg):
        _logger.debug("Sent %s bytes >>>%s<<<", len(msg), msg)        
        
    def receive(self):
        """
        """
        while True:
            try:
                data = self._socket.recv(self.SOCKET_BUFFER_SIZE)
            except socket.error as socket_err:
                return {'command': '_InternalQuit', 
                        'args':{'socket_error_number': socket_err.errno,
                                'socket_error_str': socket_err.strerror}}
            self._received_data += data
                
            # Do we have received a MAGIC_CODE
            try:
                magic_code_idx = self._received_data.index(self.MAGIC_CODE)
            except ValueError:
                continue
            
            # Do we have we received a length=
            try:
                length_idx = self._received_data.index('length=')
            except ValueError:
                continue
            
            # extract length content from received data
            json_length = int(self._received_data[length_idx + 7:magic_code_idx])
            message_length = magic_code_idx + len(self.MAGIC_CODE) + json_length
            if message_length <= len(self._received_data):
                full_message = self._received_data[:message_length]
                self._received_data = self._received_data[message_length:]
                if len(self._received_data) > 0:
                    self.SOCKET_BUFFER_SIZE = 0
                else:
                    self.SOCKET_BUFFER_SIZE = 4096
                break
            else:
                self.SOCKET_BUFFER_SIZE = message_length - len(self._received_data)

        self.log_received(full_message)
        obj = self.decode(full_message)
        return obj

    def send(self, command, **kwargs):
        """ Build a message from parameters and send it to debugger.
        
        :param command: The command sent to the debugger
        :type command: str
        
        :param _id: Unique id of the sent message. It is generated by the client. 
                    but it can be forced.Right now, it's always `None`
                    for messages from debugger to client.
        :type _id: int
        """
        msg = self.encode({
            '_id': self._msg_id,
            'command': command,
            'args': kwargs
        })
        self._msg_id += 1
        if self._socket:
            send_bytes_count = self._socket.sendall(msg)
            self.log_sent(msg)
            return self._msg_id - 1
        raise IKPdbConnectionError("Connection lost!")



PYTHON_EXEC = "ikpdb/tests/py27tests/bin/python"
TESTED_IKPDB_HOST = '127.0.0.1'
TESTED_IKPDB_PORT = 15999
DEBUGGED_PROGRAM = "ikpdb/tests/debugged_programs/test01_launch.py"

class TestCase01Launch(unittest.TestCase):
    
    @classmethod
    def setUpClass(cls):
        #print("CWD")
        #print(os.getcwd())
        #p = subprocess.Popen(["python", "-m", "ikpdb", "tests/debugged_programs/test01_connect.py" ])
        #print(p)
        pass
    
    
    def setUp(self):
        pass
        #print("setUp")

    def tearDown(self):
        pass
        #print("tearDown")

    def test_01_launch_file_not_exists(self):
        """ Launch a non existent debugged program and get an error"""
        # launch the debugger
        # connects to it
        # get the welcome message
        cmd_line = [
            PYTHON_EXEC, 
            "-m", 
            "ikpdb", 
            "ikpdb/tests/debugged_programs/wwwwwwwwwwwwwww.py"
        ]
        res = subprocess.Popen(cmd_line,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.STDOUT)
        output, _ = res.communicate()
        self.assertEqual(res.returncode, 1, "Wrong exit code. Expected 1, got '%s'" % res.returncode)
        self.assertTrue(output.endswith("Error: 'ikpdb/tests/debugged_programs/wwwwwwwwwwwwwww.py' does not exist.\n"),
                        "Unexpected message.")

    def test_02_connect(self):
        """Launch a debugged program and connect to debugger."""
        cmd_line = [
            PYTHON_EXEC, 
            "-m", "ikpdb", 
            #"--ikpdb-log=9N",
            "--ikpdb-port=%s" % TESTED_IKPDB_PORT,
            #"--ikpdb-welcome",
            DEBUGGED_PROGRAM,
            "t02"
        ]
        dp = subprocess.Popen(cmd_line,
                             stdout=subprocess.PIPE)
        time.sleep(0.2)
        
        # connect to debugger
        ikpdb = IKPdbClient(TESTED_IKPDB_HOST, TESTED_IKPDB_PORT)
        obj = ikpdb.receive()
        self.assertEqual(obj['info_messages'][0] , u"Welcome to", "'start'/'Welcome to' message not received")
        
        # end debugged program
        # TODO: Why do we need to kill in tests while behaviour is ok when running
        dp.kill()

    def test_03_runScript(self):
        """Launch debugger, run program and wait termination"""
        cmd_line = [
            PYTHON_EXEC, 
            "-m", "ikpdb", 
            #"--ikpdb-log=9N",
            "--ikpdb-port=%s" % TESTED_IKPDB_PORT,
            #"--ikpdb-welcome",
            DEBUGGED_PROGRAM,
            "t03"
        ]
        dp = subprocess.Popen(cmd_line,
                             stdout=subprocess.PIPE)
        time.sleep(0.2)
        # connect to debugger
        ikpdb = IKPdbClient(TESTED_IKPDB_HOST, TESTED_IKPDB_PORT)
        i_msg = ikpdb.receive()
        self.assertEqual(i_msg['info_messages'][0] , u"Welcome to", "'start'/'Welcome to' message not received.")
        
        msg_id = ikpdb.send('runScript')
        
        i_msg = ikpdb.receive()
        self.assertEqual(i_msg['_id'], msg_id, "Unexpected reply to runScript command.")
        self.assertEqual(i_msg['commandExecStatus'], "ok", "IKPdb failed to run debugged program.")

        i_msg = ikpdb.receive()
        self.assertEqual(i_msg['command'], "programEnd", "programEnd message not received.")
        self.assertEqual(i_msg['result']['exit_code'], None, "Unexpected exit code.")

        # TODO: Why do we need to kill in tests while behaviour is ok when running
        dp.kill()  


